package annotations.timeout;

//-Declarative timeouts are an experimental feature as 5.5.2

//-The @Timeout annotation allows one to declare that a test, test factory, test template, or lifecycle method should fail
// if its execution time exceeds a given duration. 
//-The time unit for the duration defaults to seconds but is configurable.
//-Contrary to the assertTimeoutPreemptively() assertion, the execution of the annotated method proceeds in the main thread of the test.
// If the timeout is exceeded, the main thread is interrupted from another thread.
//-To apply the same timeout to all test methods within a test class and all of its @Nested classes,
// you can declare the @Timeout annotation at the class level. 
// It will then be applied to all test, test factory, and test template methods within that class and its @Nested classes unless
// overridden by a @Timeout annotation on a specific method or @Nested class.
// Please note that @Timeout annotations declared at the class level are not applied to lifecycle methods.
//-Declaring @Timeout on a @TestFactory method checks that the factory method returns within the specified duration but does verify the execution time
// of each individual DynamicTest generated by the factory. Please use assertTimeout() or assertTimeoutPreemptively() for that purpose.
//-If @Timeout is present on a @TestTemplate method — for example, a @RepeatedTest or @ParameterizedTest — 
// each invocation will have the given timeout applied to it.


//	Using @Timeout for Polling Tests
//-When dealing with asynchronous code, it is common to write tests that poll while waiting for something to happen before performing any assertions.
// In some cases you can rewrite the logic to use a CountDownLatch or another synchronization mechanism, but sometimes that is not possible — for example,
// if the subject under test sends a message to a channel in an external message broker and assertions cannot be performed until the message has been
// successfully sent through the channel. Asynchronous tests like these require some form of timeout to ensure they don’t hang
// the test suite by executing indefinitely, as would be the case if an asynchronous message never gets successfully delivered.

//-By configuring a timeout for an asynchronous test that polls, you can ensure that the test does not execute indefinitely.
// The following example demonstrates how to achieve this with JUnit Jupiter’s @Timeout annotation.
// This technique can be used to implement "poll until" logic very easily.
//	@Test
//	@Timeout(5) // Poll at most 5 seconds
//	void pollUntil() throws InterruptedException {
//	    while (asynchronousResultNotAvailable()) {
//          Thread.sleep(250); // custom poll interval
//	    }
//		Obtain the asynchronous result and perform assertions
//	}
//If you need more control over polling intervals and greater flexibility with asynchronous tests, consider using a dedicated library such as Awaitility.
public class AnInfo {}
